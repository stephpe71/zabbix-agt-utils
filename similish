#!/usr/bin/env bash
# ==============================================================================
# bash read function does not behave the way I'm used to
# A similish based on zabbix agent
#
# This is more a Proof of Concept for now than a reliable tool
#
# Update: it may me really useful on the field
# (well, at least once, at least for me), modulo the numerous bugs
#
# ==============================================================================
# TODO
# - DONE colorise welcome message
# - DONE pipe 'll' output through mlr & tabulate
# - ll:
#   DONE get a better extractor 
#   better display of permissions and mod. time (1 fonction specifique jq ?)
# - ltr: doit 
# - handle commands parameters : ls, grep ...
# - handle a larger number of arguments than 4
# - IN PROGRESS Possibility of calling zabbix key directly (ex: agent.version)
#
# - colorize in general => colorlib.sh
# - use a $HOME/.zashrc ?
# - a kind of top
# - handling logs (grep: sort of)
#
# CHERRY ON THE CAKE:
# - implement Ctrl-D to bail out (how ?)
# - implement command completion ??
# - implement a kind of history
#
# ------------------------------------------------------------------------------
# BUGS
# - FIXED put a maxdepth param in vdg commands
# - FIXED handle absolute pathname for cat commands...
#
# - MAINTAIN COHERENCY for CWD between standard and extended commands
# - MANAGE 'cd ..'
# - handle COMMAND ARGUMENT : ls, ll
# - EXTENDED ARGS: when not supplying WD on CL, add it to arguments
# ------------------------------------------------------------------------------
# PROBLEMS: handle / in homogeneous way
# /, //var/log, 
# ==============================================================================
# Section CONFIGURATION

HOST=${1:-127.0.0.1}

VERSION="0.5f (10-02-2026 afternoon)"

DEBUG="1"
DEBUG=""

TIMEOUT=4

# In this script we use SCRIPTNAME, as PROGRAM_NAME is already used for prompt
SCRIPTNAME=$(basename $0)

# Not decided yet! SimiliSH sounds funnier in french, but
# Zash is shorter and more logical
PROGRAM_NAME="SimiliSH"
PROGRAM_NAME="ZaSH"

PROMPT="${PROGRAM_NAME}> "

GRID_STYLE=grid
GRID_STYLE=plain

# Set to null if system.run disact
#EXTENDED_COMMANDS=""
EXTENDED_COMMANDS=true

# Let's from there
CWD="/tmp"

JQ_LL_EXTRACTOR="{type:.type, perms:.permissions, user:.user, group:.group, size:.size, datetime:.time.change, name:.basename}"

JQ_PS_EXTRACTOR="{pid:.pid, name:.name, user:.user, vsize:.vsize, rss:.rss, cmdline:.cmdline}"
JQ_PS_SORT_KEY=".rss"

# Maintain value of zabbix
# ==============================================================================
# Section FUNCTIONS

function usage {

    cat <<EOF

    $SCRIPTNAME: usage:

    $SCRIPTNAME is a minimal read only shell (sort of) based on zabbix agent
    various keys (vfs.dir.get, vfs.file.*, system.run if avail., etc ...)

    Not implemented: pipes, completion, modifications, awk, sed ...

    Options:

	-h: show this usage message and exit
	-V: show version and exit

EOF
}

# TBD 
function cleanup {
    rm -f tmp.json out.dat
}

function display_welcome_message {

    local welcome_string="WELCOME TO ${PROGRAM_NAME}"

    echo
    #echo "### $(colored $welcome_string $BRIGHT) ###"
    echo "### $welcome_string ###"
    echo "## A 'shell' (sort of) based on zabbix agent capabilities ###"
    echo

    echo "## You are connected to host '$(colored $HOST $BRIGHT)'"
    echo "## Agent version there is '$(colored $agent_version $BRIGHT)'"
    [[ ! -z $EXTENDED_COMMANDS ]] && echo "## Extended commands (system.run) are $(colored activated $BRIGHT)..."
    echo
}


function help {
    cat<<EOF
    ## A 'shell' (sort of) based on zabbix agent capabilities ###
    # Some commands:
     pwd: display current directory
     cd:  change current directory
     ls:  display content of current directory
     cat: display content of given file
     {ck|md5}sum: calculate the given checksum of file

     if extended commands (system.run[*]) are activated,
     all commands on remote host (accessible to zabbix users) may be called


EOF
}

# factorizes everything before key
function zg-k {
   local key="$1"

   zabbix_get -s $HOST -k "${key}"
}


# FIXME: carefully handle quoting
function zg_sr {
    local cmd="$1"
    local key="system.run[${cmd}]"

    zg-k "$key"
}

# FIXME: should be factorized 
function pathname_exists_p {
    local dirpath="$1"
    local kind="${2:-file}"
    
    local key="vfs.file.exists[${dirpath},${kind}]"

    zg-k "$key"
}

# ==============================================================================
#  MAIN
# FIXME: put in a getopt while loop
#set -x
#local flag OPTIND=1 OPTARG="" OPTERR=0

filename="colorlib.sh"

if [[ ! -r $filename ]]; then
    echo "$filename: not found, exiting ... "; exit 1;
else
    source $filename
fi

while getopts "hV" flag "$@"
do
    case $flag in
	h) usage && exit 0 ;;
	V) echo "$SCRIPTNAME: $VERSION" && exit 0 ;;

	*) exit 1 ;;
    esac
done

# Does agent respond on specified target?
zabbix_get -t $TIMEOUT -s $HOST -k agent.ping >/dev/null
[[ $? -ne 0 ]] && echo "$SCRIPTNAME[agent.ping]: error: agent did respond on time, exiting..." && exit 2

# Does agent support proc.get key? (only recent versions)
agent_version=$(zabbix_get -t $TIMEOUT -s $HOST -k agent.version)
[[ ! -z $DEBUG ]] && echo "agent_version='$agent_version'"
case $agent_version in
    [6].[246]*)   : ;;
    [7-9].*)      : ;;
    *)		  echo "zabbix agent version: too old version (key 'proc.get' not supported)" && exit 3 ;;
esac

# Does agent support proc.get key? (only recent versions)
zabbix_get -t $TIMEOUT -s $HOST -k "system.run[date]" >/dev/null
if [[ $? -ne 0 ]]; then
    echo "WARNING: zabbix agent does not appear to support 'system.run' key, extended functionalities will be disabled... "
    EXTENDED_COMMANDS=""
else
    :
fi

# ==============================================================================
current_rc=0

display_welcome_message

while true
do
    echo -e "$(colored $PROMPT $BRIGHT)\c"
    read cmd arg1 arg2 arg3 arg4 arg5
    
    [[ -n $DEBUG ]] && echo "cmd='$cmd' arg1='$arg1' arg2='$arg2' arg3='$arg3'"
    
    # Better used with implicit $* arguments?
    # HOW do we handle 
    case "$cmd" in

	pwd)	echo $CWD ;;

	# 
	cd)
	    local OLDCWD=$CWD
	    case $arg1 in
		    /*) CWD=$arg1 ;;
		    ..) CWD=${CWD%/*}; [[ $CWD = "" ]] && CWD="/" ;;
		     *) CWD=$CWD/$arg1 ;; #FIXME: add check of existence !!
		esac
	    # FIXME: tests if exists!!
	    if [[ $(pathname_exists_p "$CWD" dir) -ne 1 ]]; then
		echo "$SCRIPTNAME: $CWD does not exist on remote host!!"
		CWD=$OLDCWD
	    fi
	    
	    # FIXME: check validity of hack!!
	    [[ $CWD != "/" ]] && CWD=$(echo $CWD | perl -pe 's@(/+)@/@g')
	    echo $CWD
	    ;;
	
	cat)
	    case $arg1 in
		    /*) pathname=$arg1 ;;
		     *) pathname=$CWD/$arg1 ;; #FIXME: add check of existence !!
	    esac
	    #zabbix_get -s $HOST -k "vfs.file.contents[$pathname]"
	    zg-k "vfs.file.contents[$pathname]"
            ;;

	# ----------------------------------------------------------------------
	help)	usage ;;

	# ----------------------------------------------------------------------
	# FIXME: to be handled together
	# handle '..' and co 
	ls)
	    zg-k "vfs.dir.get[$CWD,,,,,0]" | jq -cr '.[] | .basename' ;;

	ll)
	    # | mlr --j2t cat | tabulate -1 -f pipe
	    zg-k "vfs.dir.get[$CWD,,,,,0]" | jq -cMr ".[] | $JQ_LL_EXTRACTOR" | mlr --j2t cat | tabulate -1 -f ${GRID_STYLE} ;;

	ltr) # FIXME: fix duplication with 
	    zg-k "vfs.dir.get[$CWD,,,,,0]" | jq -cMr ". | sort_by(.time.change) | .[] | $JQ_LL_EXTRACTOR" | mlr --j2t cat | tabulate -1 -f ${GRID_STYLE}
	    ;;
 
	# ----------------------------------------------------------------------
	ps) # FEATURE: handle us and aux
	    zg-k "proc.get" | jq -cMr ". | sort_by(${JQ_PS_SORT_KEY}) | .[] | $JQ_PS_EXTRACTOR" | mlr --j2t cat | tabulate -1 -f ${GRID_STYLE}
	    ;;

	# ----------------------------------------------------------------------
	top) echo "NOT IMPLEMENTED, YET..." ;;

	# ----------------------------------------------------------------------
	cksum|md5sum)
	    case $arg1 in
		    /*) pathname=$arg1 ;;
		     *) pathname=$CWD/$arg1 ;; #FIXME: add check of existence !!
	    esac
	    
	    zg-k "vfs.file.${cmd}[$pathname]"
            ;;

	grep) # FIXME: should handle grep options, if possible
	    regexp="$arg1"
	    case $arg2 in
		    /*) pathname=$arg2 ;;
		     *) pathname=$CWD/$arg2 ;; #FIXME: add check of existence !!
	    esac
	    zg-k "vfs.file.regexp[$pathname,$regexp]"
	    ;;

	uname)		zg-k "system.uname"   ;;
	hostname)	zg-k "system.hostname" ;;
	uptime)		zg-k "system.uptime" ;;

        version)	echo "$PROGRAM_NAME version $VERSION" ;;

	exit|quit)	exit $current_rc ;;

	help)		help ;;

	# ------------------------------------------------------------------------
	# DIRECT CALL of zabbix keys
	# in case key is not recognized we have a simple direct message
	agent.*|kernel.*|net.*|proc.*|system.*|vfs.*)
	    zg-k "$cmd"
	    ;;
	
	# ------------------------------------------------------------------------
	"")		: ;; # handle pointless press of 'Enter' key
	
	*)   if [[ ! -z $EXTENDED_COMMANDS ]]; then
	       # FIXME: handle CWD
	       zg-k "system.run[$cmd $arg1 $arg2 $arg3 $arg4]"
	     else
		 echo "Unknown command: '$cmd'"
	     fi ;;
    esac
done

[[ -z $DEBUG ]] && cleanup

exit $current_rc

