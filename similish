#!/usr/bin/env zsh
#!/usr/bin/env bash
# ==============================================================================
# bash read function does not behave the way I'm used to
# A similish based on zabbix agent

# This is more a Proof of Concept for now than a reliable tool
# Not sure if or how it might be useful
# ==============================================================================
# TODO
# - DONE colorise welcome message
# - DONE pipe 'll' output through mlr & tabulate
# - ll:
#   DONE get a better extractor 
#   better display of permissions and mod. time (1 fonction specifique jq ?)
# - ltr: doit 
# - handle commands parameters : ls, grep ...
# - handle a larger number of arguments than 4
#
# - colorize in general => colorlib.sh

#
# BUGS
# - FIXED put a maxdepth param in vdg commands
# - FIXED handle absolute pathname for cat commands...

# - MAINTAIN COHERENCY for CWD between standard and extended commands
# - find a way to split arguments with bash 'read' cmd
#

# ==============================================================================
# Section CONFIGURATION
#
#set -x
#

HOST=${1:-127.0.0.1}

VERSION="0.3a (13-10-2025 morning)"

DEBUG="1"
DEBUG=""

TIMEOUT=5

SCRIPTNAME=$(basename $0)

# Not decided yet! SimiliSH sounds funnier in french, but
# Zash is shorter and more logical
PROGRAM_NAME="SimiliSH"
PROGRAM_NAME="ZaSH"

PROMPT="${PROGRAM_NAME}> "


# Set to null if system.run disact
#EXTENDED_COMMANDS=""
EXTENDED_COMMANDS=true

# Let's from there
CWD="/tmp"

# "basename": "231877",
# "pathname": "/tmp/.ICE-unix/231877",
# "dirname": "/tmp/.ICE-unix",
# "type": "sock",
# "user": "sperrot",
# "group": "sperrot",
# "permissions": "0777",
# "uid": 1000,
# "gid": 1000,
# "size": 0,

JQ_LL_EXTRACTOR="{perms:.permissions,user:.user,group:.group,size:.size,datetime:.time.change,name:.basename}"

# ==============================================================================
# Section FUNCTIONS

function usage {

    cat <<EOF

    $SCRIPTNAME: usage:

    $SCRIPTNAME is a simili shell based on zabbix agent variious keys ...

    Options:

	-h: show this usage message and exit
	-V; show version and exit

EOF
}

# TBD k
function cleanup {
    rm -f tmp.json out.dat
}

function welcome {

    local welcome_string="WELCOME TO ${PROGRAM_NAME}"

    echo
    #echo "### $(colored $welcome_string $BRIGHT) ###"
    echo "### $welcome_string ###"
    echo "## A 'shell' (sort of) based on zabbix agent capabilities ###"
    echo

    echo "## You are connected to host '$(colored $HOST $BRIGHT)'"
    echo "## Agent version there is '$(colored $agent_version $BRIGHT)'"
    [[ ! -z $EXTENDED_COMMANDS ]] && echo "## Extended commands are $(colored activated $BRIGHT)..."
    echo
}

function help {
    echo
    echo "# Some commands:"
    echo " pwd, cd, ls, cat"
    echo
}

# ==============================================================================
#  MAIN
# FIXME: put in a getopt while loop
#set -x
#local flag OPTIND=1 OPTARG="" OPTERR=0

source "colorlib.sh"

while getopts "hV" flag "$@"; do

    case $flag in

	h) usage && exit 0 ;;
	V) echo "$SCRIPTNAME: $VERSION" && exit 0 ;;

	*) exit 1 ;;
	
    esac

done

# Does agent respond on specified target?
zabbix_get -t $TIMEOUT -s $HOST -k agent.ping >/dev/null
[[ $? -ne 0 ]] && echo "$SCRIPTNAME[agent.ping]: error: agent did respond on time, exiting..." && exit 2

# Does agent support proc.get key? (only recent versions)
agent_version=$(zabbix_get -t $TIMEOUT -s $HOST -k agent.version)
[[ ! -z $DEBUG ]] && echo "agent_version='$agent_version'"
case $agent_version in

    [6].[246]*)   : ;;
    [7-9].*)      : ;;
    *)		  echo "zabbix agent version: too old version (key 'proc.get' not supported)" && exit 3 ;;
esac

# Does agent support proc.get key? (only recent versions)
zabbix_get -t $TIMEOUT -s $HOST -k "system.run[date]" >/dev/null
if [[ $? -ne 0 ]]; then
    echo "WARNING: zabbix agent does not appear to support 'system.run' key, extended functionalities will be disabled... "
    EXTENDED_COMMANDS=""
else
    : # this message is replaced by note in welcome message
    # echo
    # echo "> zabbix agent appears to support 'system.run' key, extended cmds are enabled... " && EXTENDED_COMMANDS="true"
    # echo
fi

# ==============================================================================
current_rc=0

welcome

while true
do
    echo -e "$PROMPT\c"
    read input
    #read

    [[ -n $DEBUG ]] && echo "input='$input'"
    echo $input | read cmd arg1 arg2 arg3 arg4
    [[ -n $DEBUG ]] && echo "cmd='$cmd' arg1='$arg1' arg2='$arg2' arg3='$arg3'"
    
    # Better used with implicit $* arguments?
    case "$cmd" in

	# Fixme: special handling of /
	pwd)	echo $CWD ;;

	cd)	case $arg1 in
		    /*) CWD=$arg1 ;;
		     *) CWD=$CWD/$arg1 ;; #FIXME: add check of existence !!
		esac
		CWD=$(echo $CWD | perl -pe 's@(/+)@/@g')
	        echo $CWD
		;;
	
	cat) case $arg1 in
		    /*) pathname=$arg1 ;;
		     *) pathname=$CWD/$arg1 ;; #FIXME: add check of existence !!
	     esac
	    zabbix_get -s $HOST -k "vfs.file.contents[$pathname]"
            ;;
	
	# -rw-r--r-- 1 sperrot sperrot  352 10 oct.  15:19 IDEES
	ls)
	    zabbix_get -s $HOST -k "vfs.dir.get[$CWD,,,,,0]" | jq -cr '.[] | .basename' ;;

	ll)
	    # | mlr --j2t cat | tabulate -1 -f pipe
	    zabbix_get -s $HOST -k "vfs.dir.get[$CWD,,,,,0]" | jq -cMr ".[] | $JQ_LL_EXTRACTOR" \
	    | mlr --j2t cat | tabulate -1 -f plain
	    ;;

	ltr) # FIXME: fix duplication with 
	    zabbix_get -s $HOST -k "vfs.dir.get[$CWD,,,,,0]" | jq -cMr ". | sort_by(.time.change) | .[] | $JQ_LL_EXTRACTOR" \
	    | mlr --j2t cat | tabulate -1 -f plain
	    ;;

	cksum|md5sum) pathname=$CWD/$arg1
	    zabbix_get -s $HOST -k "vfs.file.${cmd}[$pathname]"
            ;;
	grep) # FIXME: should handle grep options, if possible
	    regexp="$arg1"
	    pathname=$CWD/$arg2
	    zabbix_get -s $HOST -k "vfs.file.regexp[$pathname,$regexp]"
	    ;;

	uname)		zabbix_get -s $HOST -k "system.uname"   ;;
	hostname)	zabbix_get -s $HOST -k "system.hostname" ;;
	uptime)		zabbix_get -s $HOST -k "system.uptime" ;;

	exit|quit)	exit $current_rc ;;

	help)	help ;;

	"")	: ;; # handle useless use of 'Enter' key
	
	*)   if [[ ! -z $EXTENDED_COMMANDS ]]; then
	       zabbix_get -s $HOST -k "system.run[$cmd $arg1 $arg2 $arg3 $arg4]"
	     else
		 echo "Unknown command: '$cmd'"
	     fi ;;
    esac
done

[[ -z $DEBUG ]] && cleanup

exit 0



